## 1.函数体外只能定义全局变量或者对象，而不能执行语句
具体执行的语句只能写到函数体里，然后调用函数。比如在全局中std::cout << "hello world"是不可以的。只能把他放到一个函数中。

## 2.单例模式
可以在函数定义时创建一个新的静态变量，然后如果再掉用的时候就不会在执行新建这个指令了。下图中b，c不再新建，而是直接返回a创建的单例地址。
![](../_resources/6f122627545d3bd39f8342408d507fb0.png)

## 3 类内static、override声明，在类外不需要重复说明，但是const函数需要。
 在类内声明时要加static声明，在类外定义时不加。类似的还有override、virtual。但是const不包含在内。

![](../_resources/eab28edcbbe98c5577a17552506d329d.png)![](../_resources/1333a04b59631b6f89953770787fd5d7.png)
![[Pasted image 20230724170552.png]]

![[Pasted image 20230724170616.png]]


## 4.类内定义函数时，编译器会自动加上inline，在类外时需要手动在类外定义时加上，而在类内无需加。
![](../_resources/2f087ee70a327ec416847849915c3b62.png)![](../_resources/23efc83a8be44e682807256f92e750c2.png)

## 5.在google规范中，一般bool func(const B &input，C \*output)，
这样做的原因是，首先bool天然具有实际的意义，比如一个precess类的函数，天然需要返回是否成功。其次，如果output太多，一般也会这样写。之所以输出写成指针是因为比较好辨别。如果返回的只是一个值，那么A func(const &B)也完全没问题。

## 6.C++中特殊的构造函数：析构，拷贝构造，拷贝复制，移动构造，移动赋值，遵循三五原则：

也叫三五法则，指的是析构，拷贝构造，拷贝复制，移动构造，移动赋值需要同时出现的消失。要么都定义，要么都不定义。

C++三法则：如果需要**析构函数，则一定需要拷贝构造函数和拷贝赋值操作符**。
在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“**C++五法则**”；
也就是说，**“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的**；为了统一称呼，后来人们干把它叫做“C++ 三/五法则”；


1. 只要不涉及到指针和内存，**就不要去自己声明拷贝构造，拷贝复制，移动构造，移动赋值和析构**(五法则，针对C++11之后)，默认构造可以用defalut来声明。如果涉及到指针和内存，那么就要遵循**三原则**(同时定义析构，拷贝构造，拷贝赋值)。
在涉及指针和内存时需要定义析构函数的原因是这样：合成的析构函数不足以释放类所拥有的资源。同时在拷贝中，有指针类型的成员，我们必须防止浅拷贝问题，所以，一定需要拷贝构造函数和赋值操作符，这两个函数是防止浅拷贝问题所必须的。

3. 不定义移动构造和移动赋值肯定不会出错，但是可能性能较低。
4. 如果声明了移动操作，则删除拷贝操作（拷贝构造和拷贝复制）

如果一个类定义了一个移动构造函数/移动[运算符](https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020)，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的（因为生成的会有危险，不如直接删除），也就是说定义了一个移动操作的类也要定义自己的拷贝操作，否则拷贝操作会被默认定义为删除的。


1.
![](../_resources/b9d3fbbc52c6e4f62f2ba1e02093fff8.png)![](../_resources/8967eea7b61640f777203611213d8ac2.png)

## 6.什么时候传值和传引用


![](../_resources/5321c4a7868e8074bccebd193f3d810c.png)

补充：智能指针，一般也可要传引用。

![[Pasted image 20230724170819.png]]